from __future__ import annotations

from django.db import models
from django.db.models import Manager


class App(models.Model):
    """
    Represents one of the user's iOS apps.

    Used for organizing keywords into groups ‚Äî each keyword can
    optionally be associated with an app.

    When added via App Store lookup, track_id stores the iTunes
    numeric ID so we can find the app's rank in search results.
    """

    id: int  # Auto-generated by Django, declared for type checkers
    keywords: Manager[Keyword]

    name = models.CharField(max_length=200)
    bundle_id = models.CharField(
        max_length=200,
        blank=True,
        default="",
        help_text="e.g., com.example.myapp",
    )
    track_id = models.BigIntegerField(
        null=True,
        blank=True,
        unique=True,
        help_text="iTunes trackId ‚Äî used for rank tracking in search results",
    )
    store_url = models.URLField(
        blank=True,
        default="",
        help_text="App Store URL",
    )
    icon_url = models.URLField(
        blank=True,
        default="",
        help_text="App icon URL from iTunes",
    )
    seller_name = models.CharField(
        max_length=200,
        blank=True,
        default="",
        help_text="Developer/publisher name",
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["name"]

    def __str__(self):
        return self.name


class Keyword(models.Model):
    """
    A keyword being tracked for ASO research.

    Can optionally be linked to an App for categorization.
    """

    id: int  # Auto-generated by Django, declared for type checkers
    results: Manager[SearchResult]

    keyword = models.CharField(max_length=200)
    app = models.ForeignKey(
        App,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="keywords",
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("keyword", "app")
        ordering = ["-created_at"]

    def __str__(self):
        if self.app:
            return f"{self.keyword} ({self.app.name})"
        return self.keyword


class SearchResult(models.Model):
    """
    Stores the result of a keyword search at a point in time.

    Contains popularity score (from Apple), difficulty score (calculated),
    and the raw competitor data from iTunes Search API.
    """

    id: int  # Auto-generated by Django, declared for type checkers

    keyword = models.ForeignKey(
        Keyword,
        on_delete=models.CASCADE,
        related_name="results",
    )
    popularity_score = models.IntegerField(
        null=True,
        blank=True,
        help_text="1-100 estimated popularity score.",
    )
    difficulty_score = models.IntegerField(
        help_text="1-100 calculated difficulty score",
    )
    difficulty_breakdown = models.JSONField(
        default=dict,
        help_text="Component scores breakdown",
    )
    competitors_data = models.JSONField(
        default=list,
        help_text="Array of top competitor app dicts from iTunes",
    )
    app_rank = models.IntegerField(
        null=True,
        blank=True,
        help_text="App's 1-indexed rank in top-200 iTunes results (null if not found)",
    )
    country = models.CharField(
        max_length=5,
        default="us",
        help_text="Country code used for this search",
    )
    searched_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-searched_at"]

    def __str__(self):
        return f"{self.keyword.keyword} ‚Äî {self.searched_at:%Y-%m-%d %H:%M}"

    @property
    def difficulty_label(self):
        """Human-readable difficulty interpretation."""
        score = self.difficulty_score
        if score <= 15:
            return "Very Easy"
        elif score <= 35:
            return "Easy"
        elif score <= 55:
            return "Moderate"
        elif score <= 75:
            return "Hard"
        elif score <= 90:
            return "Very Hard"
        return "Extreme"

    @property
    def difficulty_color(self):
        """Tailwind color class for the difficulty score."""
        score = self.difficulty_score
        if score <= 15:
            return "text-green-400"
        elif score <= 35:
            return "text-green-300"
        elif score <= 55:
            return "text-yellow-400"
        elif score <= 75:
            return "text-orange-400"
        elif score <= 90:
            return "text-red-400"
        return "text-red-600"

    @property
    def targeting_advice(self):
        """Return (icon, label, css_classes, description) for ASO targeting."""
        diff = self.difficulty_score
        pop = self.popularity_score

        if pop is not None:
            if pop >= 40 and diff <= 40:
                return ("üéØ", "Sweet Spot", "bg-green-900/20 text-green-300 border-green-500/20",
                        "High popularity + low difficulty ‚Äî ideal keyword to target with good ASO.")
            elif pop >= 40 and diff <= 60:
                return ("‚úÖ", "Good Target", "bg-green-900/20 text-green-300 border-green-500/20",
                        "Solid popularity with manageable difficulty.")
            elif pop >= 40 and diff > 60:
                return ("‚öîÔ∏è", "Worth Competing", "bg-yellow-900/20 text-yellow-300 border-yellow-500/20",
                        "High demand but tough competition. Consider long-tail variants.")
            elif 30 <= pop < 40 and diff <= 40:
                return ("üíé", "Hidden Gem", "bg-blue-900/20 text-blue-300 border-blue-500/20",
                        "Moderate volume with little competition. Good for niche apps.")
            elif 30 <= pop < 40 and diff <= 60:
                return ("üëç", "Decent Option", "bg-slate-800 text-slate-300 border-white/10",
                        "Moderate demand and competition. Can work as a supporting keyword.")
            elif pop < 30 and diff <= 30:
                return ("üîç", "Low Volume", "bg-slate-800 text-slate-300 border-white/10",
                        "Easy to rank but few people search for this. Best as a supporting keyword.")
            elif pop < 30 and diff > 30:
                return ("üö´", "Avoid", "bg-red-900/20 text-red-300 border-red-500/20",
                        "Low search volume with notable competition.")
            else:
                return ("‚öîÔ∏è", "Challenging", "bg-yellow-900/20 text-yellow-300 border-yellow-500/20",
                        "Strong competition. Focus on long-tail variants.")
        else:
            if diff <= 25:
                return ("üü¢", "Easy to Rank", "bg-green-900/20 text-green-300 border-green-500/20",
                        "Low competition ‚Äî a well-optimized app can rank quickly.")
            elif diff <= 50:
                return ("üü°", "Moderate", "bg-yellow-900/20 text-yellow-300 border-yellow-500/20",
                        "Achievable with strong ASO.")
            elif diff <= 75:
                return ("üü†", "Competitive", "bg-orange-900/20 text-orange-300 border-orange-500/20",
                        "Consider long-tail variants.")
            else:
                return ("üî¥", "Very Competitive", "bg-red-900/20 text-red-300 border-red-500/20",
                        "Dominated by established apps. Target easier keywords first.")
